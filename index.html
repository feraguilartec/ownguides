<html>
<head>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-look-at-component@1.0.0/dist/aframe-look-at-component.min.js"></script> 
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-xr-hand-tracking@1.2.0/dist/aframe-xr-hand-tracking.min.js"></script>
</head>
<body>
  <!-- <a-scene xr-mode-ui="XRMode: xr" xrweb="allowedFeatures: [ 'hand-tracking', 'eye-tracking' ]" raycaster="objects: .button" renderer="sortObjects: true; physicallyCorrectLights: false;">-->
  <a-scene obb-collider="showColliders: true" xr-mode-ui="XRMode: xr" xrweb="allowedFeatures: [ 'hand-tracking', 'eye-tracking' ]" raycaster="objects: .button" renderer="sortObjects: true; physicallyCorrectLights: false;"> 
    <a-assets>
      <img id="back_on" src="media/img/ui/back_on.png" alt="">
      <img id="back" src="media/img/ui/back.png" alt="">
      <img id="down_on" src="media/img/ui/down_on.png" alt="">
      <img id="down" src="media/img/ui/down.png" alt="">
      <img id="follow_on" src="media/img/ui/follow_on.png" alt="">
      <img id="follow" src="media/img/ui/follow.png" alt="">
      <img id="fwd_on" src="media/img/ui/fwd_on.png" alt="">
      <img id="fwd" src="media/img/ui/fwd.png" alt="">
      <img id="min_on" src="media/img/ui/min_on.png" alt="">
      <img id="min" src="media/img/ui/min.png" alt="">
      <img id="play_on" src="media/img/ui/play_on.png" alt="">
      <img id="play" src="media/img/ui/play.png" alt="">
      <img id="pause_on" src="media/img/ui/pause_on.png" alt="">
      <img id="pause" src="media/img/ui/pause.png" alt="">
      <img id="rotate_on" src="media/img/ui/rotate_on.png" alt="">
      <img id="rotate" src="media/img/ui/rotate.png" alt="">
      <img id="screen" src="media/img/ui/screen.png" alt="">
      <img id="screen_s" src="media/img/ui/screen_s.png" alt="">
      <img id="step_active" src="media/img/ui/step_on.png" alt="">
      <img id="step_on" src="media/img/ui/step_on.png" alt="">
      <img id="step" src="media/img/ui/step.png" alt="">
      <img id="steps_active" src="media/img/ui/steps_on.png" alt="">
      <img id="steps_on" src="media/img/ui/steps_on.png" alt="">
      <img id="steps" src="media/img/ui/steps.png" alt="">
      <img id="up_on" src="media/img/ui/up_on.png" alt="">
      <img id="up" src="media/img/ui/up.png" alt="">
      <img id="cascade_bg" src="media/img/ui/cascade_bg.png" alt="">
      <img id="page_bg" src="media/img/ui/page_bg.png" alt="">
      <img id="volume_mute" src="media/img/ui/mute.png" alt="">
      <img id="volume_voice" src="media/img/ui/volume.png" alt="">
      <a-asset-item id="bg" src="media/models/bg.glb"></a-asset-item>
    </a-assets>

    <a-entity position="0 1.4 -3" guide></a-entity>

    <!-- Controladores para manos -->
    <!-- <a-entity id="leftHand" hand-tracking-grab-controls="hand: left;" obb-collider></a-entity> -->
    <!-- <a-entity id="rightHand" hand-tracking-grab-controls="hand: right;" obb-collider></a-entity> -->
    <a-entity id="leftHand" hand-tracking-grab-controls="hand: left;"></a-entity>
    <a-entity id="rightHand" hand-tracking-grab-controls="hand: right;"></a-entity>

    <!-- Cámara con look-controls y wasd-controls -->
    <a-camera id="camara-cursor" wasd-controls look-controls>
      <a-entity id="cursor-animado" 
          cursor="fuse: true; rayOrigin: entity; fuseTimeout: 1500" 
          cursor-fuse-click
          raycaster="objects: .button" 
          position="0 0 -1" 
          material="color: #6de5f7; shader: flat" 
          geometry="primitive: torus; radius: 0.01; radiusTubular: 0.002; segmentsTubular: 32; segmentsRadial: 3"
          animation__arc="property: geometry.arc; from: 0; to: 360; loop: false; dur: 1400; easing: linear; enabled: false;"
          animation__segments="property: geometry.segmentsTubular; from: 1; to: 32; loop: false; dur: 1400; easing: linear; enabled: false;">
</a-entity>

    </a-camera>
  </a-scene>

  <!-- Scripts Guides -->
  <script src="js/textToSpeech.js"></script>
  <script src="js/listeners.js"></script>
  <script src="js/guides.js"></script>
  <script>
    AFRAME.registerComponent('log-on-intersect', {
      init: function () {
        const button = document.querySelector('#fwd_button');
        const button2 = document.querySelector('#back_button');
        const button3 = document.querySelector('#up_button');
        const button4 = document.querySelector('#down_button');
        const buttons = document.querySelectorAll('.button');
        const cursor = document.querySelector('#cursor-animado');

        const resetCursor = () => {
        // Configurar el estado inicial (toro completo)
        cursor.setAttribute('geometry', {
            primitive: 'torus',
            radius: 0.01,
            radiusTubular: 0.002,
            segmentsTubular: 32,
            segmentsRadial: 3,
            arc: 360, // Mostrar el toro completo
          });
        };
        
        button.addEventListener('raycaster-intersected', () => {
          // Reiniciar y reproducir animaciones al entrar
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: 0,
            to: 360,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: 1,
            to: 32,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
        });

        button2.addEventListener('raycaster-intersected', () => {
          // Reiniciar y reproducir animaciones al entrar
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: 0,
            to: 360,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: 1,
            to: 32,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
        });

        button3.addEventListener('raycaster-intersected', () => {
          // Reiniciar y reproducir animaciones al entrar
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: 0,
            to: 360,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: 1,
            to: 32,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
        });

        button4.addEventListener('raycaster-intersected', () => {
          // Reiniciar y reproducir animaciones al entrar
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: 0,
            to: 360,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: 1,
            to: 32,
            loop: false,
            dur: 1400,
            easing: 'linear',
            enabled: true,
          });
        });
  
        button.addEventListener('raycaster-intersected-cleared', () => {
          // Obtener progreso actual
          const arcProgress = parseFloat(cursor.getAttribute('geometry').arc || 0);
          const segmentProgress = parseFloat(cursor.getAttribute('geometry').segmentsTubular || 1);
  
          // Configurar animación inversa
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: arcProgress,
            to: 0,
            loop: false,
            dur: 1400 * (arcProgress / 360),
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: segmentProgress,
            to: 1,
            loop: false,
            dur: 1400 * ((segmentProgress - 1) / 31),
            easing: 'linear',
            enabled: true,
          });

          cursor.addEventListener('animationcomplete', (event) => {
            resetCursor();
          });
        });

        button2.addEventListener('raycaster-intersected-cleared', () => {
          // Obtener progreso actual
          const arcProgress = parseFloat(cursor.getAttribute('geometry').arc || 0);
          const segmentProgress = parseFloat(cursor.getAttribute('geometry').segmentsTubular || 1);
  
          // Configurar animación inversa
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: arcProgress,
            to: 0,
            loop: false,
            dur: 1400 * (arcProgress / 360),
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: segmentProgress,
            to: 1,
            loop: false,
            dur: 1400 * ((segmentProgress - 1) / 31),
            easing: 'linear',
            enabled: true,
          });

          cursor.addEventListener('animationcomplete', (event) => {
            resetCursor();
          });
        });

        button3.addEventListener('raycaster-intersected-cleared', () => {
          // Obtener progreso actual
          const arcProgress = parseFloat(cursor.getAttribute('geometry').arc || 0);
          const segmentProgress = parseFloat(cursor.getAttribute('geometry').segmentsTubular || 1);
  
          // Configurar animación inversa
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: arcProgress,
            to: 0,
            loop: false,
            dur: 1400 * (arcProgress / 360),
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: segmentProgress,
            to: 1,
            loop: false,
            dur: 1400 * ((segmentProgress - 1) / 31),
            easing: 'linear',
            enabled: true,
          });

          cursor.addEventListener('animationcomplete', (event) => {
            resetCursor();
          });
        });

        button4.addEventListener('raycaster-intersected-cleared', () => {
          // Obtener progreso actual
          const arcProgress = parseFloat(cursor.getAttribute('geometry').arc || 0);
          const segmentProgress = parseFloat(cursor.getAttribute('geometry').segmentsTubular || 1);
  
          // Configurar animación inversa
          cursor.setAttribute('animation__arc', {
            property: 'geometry.arc',
            from: arcProgress,
            to: 0,
            loop: false,
            dur: 1400 * (arcProgress / 360),
            easing: 'linear',
            enabled: true,
          });
  
          cursor.setAttribute('animation__segments', {
            property: 'geometry.segmentsTubular',
            from: segmentProgress,
            to: 1,
            loop: false,
            dur: 1400 * ((segmentProgress - 1) / 31),
            easing: 'linear',
            enabled: true,
          });

          cursor.addEventListener('animationcomplete', (event) => {
            resetCursor();
          });
        });
      },
    });
  
    // Agregar el componente al cursor (o donde uses el raycaster)
    document.querySelector('[raycaster]').setAttribute('log-on-intersect', '');
  </script>
  <script>
    AFRAME.registerComponent('cursor-fuse-click', {
      init: function () {
        var el = this.el;

        
        // Funciones para manejar los eventos
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
  
        // Agregar los listeners para mousedown y mouseup
        el.addEventListener('mousedown', this.onMouseDown);
        el.addEventListener('mouseup', this.onMouseUp);
      },
      remove: function () {
        var el = this.el;
        el.removeEventListener('mousedown', this.onMouseDown);
        el.removeEventListener('mouseup', this.onMouseUp);
      },
      onMouseDown: function (evt) {
        // Manejar el evento mousedown
        //console.log('Evento mousedown detectado');
      },
      onMouseUp: function (evt) {
        // Manejar el evento mouseup
        // Obtener las intersecciones actuales del raycaster
      var raycaster = this.el.components.raycaster;
      var intersections = raycaster.intersections;

      if (intersections && intersections.length > 0) {
        // Iterar sobre las intersecciones para encontrar un elemento con la clase 'button'
        for (var i = 0; i < intersections.length; i++) {
          var intersectedEl = intersections[i].object.el;

          if (intersectedEl && intersectedEl.classList && intersectedEl.classList.contains('button')) {
            // Disparar el evento de clic en el elemento intersectado
            intersectedEl.emit('click', {intersectedEl: intersectedEl});
            console.log('Evento clic disparado en:', intersectedEl);
            break; // Salir del bucle después de encontrar el primer botón
          }
        }
      }
  
        // Obtener el elemento intersectado
        var intersections = this.el.components.raycaster.intersections;
        if (intersections.length > 0) {
          var intersectedEl = intersections[0].object.el;
  
          // Verificar si el elemento tiene la clase 'button' o el ID 'fwdButton'
          if (intersectedEl && (intersectedEl.classList.contains('button') || intersectedEl.id === 'fwdButton' || intersectedEl.id === 'backButton' || intersectedEl.id === 'downButton' || intersectedEl.id === 'upButton')) {
            // Disparar un evento de clic en el elemento intersectado
            intersectedEl.emit('click', {intersectedEl: intersectedEl});
          }
        }
      }
    });
  </script>
  
  
</body>
</html>
